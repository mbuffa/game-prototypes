// Initial implementation, with shapes. Keeping for reference.

use std::f32::consts::PI;

use macroquad::{prelude::*, miniquad::Texture};

struct Turret {
  // rect: Rect
  base: Circle,
  gunl: Rect,
  gunr: Rect
}

impl Turret {
  pub fn new() -> Self {
    // let (width, height) = (40f32, 40f32);
    // let x = (screen_width() - width) / 2f32;
    // let y = (screen_height() - height) / 2f32;

    // Base
    let x = screen_width() / 2f32;
    let y = screen_height() / 2f32;

    // Gun
    let gunwh = (6f32, 40f32);
    let gunlx = (screen_width() / 2f32) - gunwh.0 - (gunwh.0 / 2f32);
    let gunly = (screen_height() / 2f32) - gunwh.1;
    let gunrx = (screen_width() / 2f32) + gunwh.0 - (gunwh.0 / 2f32);
    let gunry = (screen_height() / 2f32) - gunwh.1;

    Self {
      // rect: Rect::new(x, y, width, height)
      base: Circle::new(x, y, 24f32),
      gunl: Rect::new(gunlx, gunly, gunwh.0, gunwh.1),
      gunr: Rect::new(gunrx, gunry, gunwh.0, gunwh.1)
    }
  }

  pub fn draw(& self) {
    // draw_rectangle(self.rect.x, self.rect.y, self.rect.w, self.rect.h, BLACK);
    draw_circle(self.base.x, self.base.y, self.base.r, WHITE);
    draw_rectangle(self.gunl.x, self.gunl.y, self.gunl.w, self.gunl.h, GRAY);
    draw_rectangle(self.gunr.x, self.gunr.y, self.gunr.w, self.gunr.h, GRAY);
  }

  pub fn update(&mut self) {
    let center = Vec2::new(screen_width() / 2f32, screen_height() / 2f32) - 60f32;

    let mp = mouse_position();
    let mouse = Vec2::new(mp.0, mp.1);
    let angle = center.angle_between(mouse);

    // let angle_d = angle * 180f32 / PI;
    // println!("Angle between turret and mouse: {}", angle_d);
  }
}

#[macroquad::main("Turret")]
async fn main() {
  let mut turret = Turret::new();
  
  loop {
    turret.update();

    clear_background(BLACK);

    turret.draw();

    next_frame().await
  }
  
}
